#!/usr/bin/python3
import xml.etree.ElementTree as ET

XML_PATH = "third_party/OpenXR-SDK/specification/registry/xr.xml"

THUNKS_WINDOWS_SIDE_ONLY = {
    "xrEnumerateInstanceExtensionProperties": 3,
    "xrCreateInstance": 4,
}

syscall_number = 5

THUNKS = [
    "xrDestroyInstance",
    "xrGetInstanceProperties",
    "xrGetSystem",
    "xrEnumerateEnvironmentBlendModes",

    "xrAcquireSwapchainImage",
    "xrApplyHapticFeedback",
    "xrAttachSessionActionSets",
    "xrBeginFrame",
    "xrBeginSession",
    "xrCreateAction",
    "xrCreateActionSet",
    "xrCreateActionSpace",
    "xrCreateReferenceSpace",
    "xrCreateSession",
    "xrCreateSwapchain",
    "xrDestroyAction",
    "xrDestroyActionSet",
    "xrDestroySession",
    "xrDestroySpace",
    "xrDestroySwapchain",
    "xrEndFrame",
    "xrEndSession",
    "xrEnumerateBoundSourcesForAction",
    "xrEnumerateReferenceSpaces",
    "xrEnumerateSwapchainFormats",
    "xrEnumerateSwapchainImages",
    "xrEnumerateViewConfigurations",
    "xrEnumerateViewConfigurationViews",
    "xrGetActionStateBoolean",
    "xrGetActionStateFloat",
    "xrGetActionStatePose",
    "xrGetActionStateVector2f",
    "xrGetCurrentInteractionProfile",
    "xrGetInputSourceLocalizedName",
    "xrGetReferenceSpaceBoundsRect",
    "xrGetSystemProperties",
    "xrGetViewConfigurationProperties",
    "xrLocateSpace",
    "xrLocateSpaces",
    "xrLocateViews",
    "xrPathToString",
    "xrPollEvent",
    "xrReleaseSwapchainImage",
    "xrRequestExitSession",
    # "xrResultToString",
    "xrStopHapticFeedback",
    "xrStringToPath",
    # "xrStructureTypeToString",
    "xrSuggestInteractionProfileBindings",
    "xrSyncActions",
    "xrWaitFrame",
    "xrWaitSwapchainImage",
]

header_comment = "This file is automatically generated by generate_thunks.py. Do not edit manually!\n\nThis file is generated from OpenXR's xr.xml file convered by the following copyright and permission notice:\n"

thunk_mac = ""
thunk_win = ""
thunk_win_gipa = "static inline XrResult wine_xrGetInstanceProcAddr(XrInstance instance, const char* name, PFN_xrVoidFunction* function) {\n"
thunk_shared = ""

thunk_mac_arr: list[str] = []


with open(XML_PATH, "r") as fr:
    xml_content = fr.read()
    root = ET.fromstring(xml_content)
    header_comment += root.find("comment").text
    header_comment = header_comment.replace("\n", "\n * ")
    header_comment = "/** " + header_comment + "\n */\n\n"
    for command in root.findall(".//commands/command"):
        proto = command.find("proto")
        if proto is None:
            continue
        protoType = proto.find("type").text
        protoName = proto.find("name").text
        if protoName not in THUNKS and protoName not in THUNKS_WINDOWS_SIDE_ONLY:
            continue
        print(protoName)
        mac_c: list[str] = []

        current_syscall_number = syscall_number
        if protoName in THUNKS_WINDOWS_SIDE_ONLY:
            current_syscall_number = THUNKS_WINDOWS_SIDE_ONLY[protoName]
        else:
            thunk_mac_arr.append("&_wine_" + protoName)
            syscall_number += 1
        
        if protoName not in THUNKS_WINDOWS_SIDE_ONLY:
            mac_c: list[str] = [
                "static NTSTATUS _wine_" + protoName + " (struct PARAMS_" + protoName + "* params) {",
                "    params->result = " + protoName + "("
            ]
        win_c: list[str] = [
            "XRAPI_ATTR XrResult XRAPI_CALL wine_" + protoName + "("
        ]
        win_c_middle: list[str] = [
            ") {",
            "    struct PARAMS_" + protoName + " params = {"
        ]
        win_c_end: list[str] = [
            "    };",
            "    NTSTATUS res = UNIX_CALL(" + str(current_syscall_number) + ", &params);",
            "    if (res != STATUS_SUCCESS) return XR_ERROR_RUNTIME_FAILURE;",
            "    return params.result;",
            "}"
        ]
        struct_h: list[str] = ["struct PARAMS_" + protoName + " {"]
        is_first = True
        for param in command.findall("param"):
            text = ""
            for c in param.itertext():
                text += c + " "
            struct_h.append("    " + text.strip() + ";")
            if protoName not in THUNKS_WINDOWS_SIDE_ONLY:
                mac_c.append("      " + ("  " if  is_first else ", ") + "params->" + param.find("name").text)
            win_c.append("  " + ("  " if  is_first else ", ") + text.strip())
            win_c_middle.append("        ." + param.find("name").text + " = " + param.find("name").text + ", ")
            is_first = False
        struct_h.append("    " + protoType + " result;")
        struct_h.append("};")
        if protoName not in THUNKS_WINDOWS_SIDE_ONLY:
            mac_c.append("    );")
            mac_c.append("    return STATUS_SUCCESS;")
            mac_c.append("}")

        if protoName in THUNKS_WINDOWS_SIDE_ONLY:
            assert len(mac_c) == 0
        else:
            thunk_mac += "\n".join(mac_c) + "\n\n"
        thunk_shared += "\n".join(struct_h) + "\n\n"
        thunk_win += "\n".join([*win_c, *win_c_middle, *win_c_end]) + "\n\n"
        thunk_win_gipa += "    if (strcmp(name, \"" + protoName + "\") == 0) {\n"
        thunk_win_gipa += "        *function = (PFN_xrVoidFunction)&wine_" + protoName + ";\n"
        thunk_win_gipa += "        return XR_SUCCESS;\n"
        thunk_win_gipa += "    }\n"

thunk_mac += "#define GENERATED_UNIX_CALLS " + ", ".join(thunk_mac_arr) + ""
thunk_win_gipa += "    return XR_ERROR_FUNCTION_UNSUPPORTED;\n}"

with open("include/unixcall.generated.h", "w") as f:
    f.write(header_comment)
    f.write(thunk_shared)
with open("mac/thunks.generated.h", "w") as f:
    f.write(header_comment)
    f.write(thunk_mac)
with open("win/thunks.generated.h", "w") as f:
    f.write(header_comment)
    f.write(thunk_win)
    f.write(thunk_win_gipa)